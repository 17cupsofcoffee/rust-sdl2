//! Graphic Primitives

use std::mem;
use std::ptr;
use std::num::ToPrimitive;
use libc::{c_void, c_int, c_char};
use sdl2::render::Renderer;
use sdl2::surface::Surface;
use sdl2::pixels;
use sdl2::get_error;

#[allow(dead_code)]
mod ll {
    /* automatically generated by rust-bindgen */

    use libc::*;
    use sdl2::render::ll::SDL_Renderer;
    use sdl2::surface::ll::SDL_Surface;
    extern "C" {
        pub fn pixelColor(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                          color: uint32_t) -> c_int;
        pub fn pixelRGBA(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                         r: uint8_t, g: uint8_t, b: uint8_t, a: uint8_t) -> c_int;
        pub fn hlineColor(renderer: *SDL_Renderer, x1: int16_t, x2: int16_t,
                          y: int16_t, color: uint32_t) -> c_int;
        pub fn hlineRGBA(renderer: *SDL_Renderer, x1: int16_t, x2: int16_t,
                         y: int16_t, r: uint8_t, g: uint8_t, b: uint8_t, a: uint8_t) ->
            c_int;
        pub fn vlineColor(renderer: *SDL_Renderer, x: int16_t, y1: int16_t,
                          y2: int16_t, color: uint32_t) -> c_int;
        pub fn vlineRGBA(renderer: *SDL_Renderer, x: int16_t, y1: int16_t,
                         y2: int16_t, r: uint8_t, g: uint8_t, b: uint8_t, a: uint8_t) ->
            c_int;
        pub fn rectangleColor(renderer: *SDL_Renderer, x1: int16_t, y1: int16_t,
                              x2: int16_t, y2: int16_t, color: uint32_t) -> c_int;
        pub fn rectangleRGBA(renderer: *SDL_Renderer, x1: int16_t, y1: int16_t,
                             x2: int16_t, y2: int16_t, r: uint8_t, g: uint8_t, b: uint8_t,
                             a: uint8_t) -> c_int;
        pub fn roundedRectangleColor(renderer: *SDL_Renderer, x1: int16_t,
                                     y1: int16_t, x2: int16_t, y2: int16_t,
                                     rad: int16_t, color: uint32_t) -> c_int;
        pub fn roundedRectangleRGBA(renderer: *SDL_Renderer, x1: int16_t,
                                    y1: int16_t, x2: int16_t, y2: int16_t,
                                    rad: int16_t, r: uint8_t, g: uint8_t, b: uint8_t,
                                    a: uint8_t) -> c_int;
        pub fn boxColor(renderer: *SDL_Renderer, x1: int16_t, y1: int16_t,
                        x2: int16_t, y2: int16_t, color: uint32_t) -> c_int;
        pub fn boxRGBA(renderer: *SDL_Renderer, x1: int16_t, y1: int16_t,
                       x2: int16_t, y2: int16_t, r: uint8_t, g: uint8_t, b: uint8_t,
                       a: uint8_t) -> c_int;
        pub fn roundedBoxColor(renderer: *SDL_Renderer, x1: int16_t,
                               y1: int16_t, x2: int16_t, y2: int16_t, rad: int16_t,
                               color: uint32_t) -> c_int;
        pub fn roundedBoxRGBA(renderer: *SDL_Renderer, x1: int16_t, y1: int16_t,
                              x2: int16_t, y2: int16_t, rad: int16_t, r: uint8_t,
                              g: uint8_t, b: uint8_t, a: uint8_t) -> c_int;
        pub fn lineColor(renderer: *SDL_Renderer, x1: int16_t, y1: int16_t,
                         x2: int16_t, y2: int16_t, color: uint32_t) -> c_int;
        pub fn lineRGBA(renderer: *SDL_Renderer, x1: int16_t, y1: int16_t,
                        x2: int16_t, y2: int16_t, r: uint8_t, g: uint8_t, b: uint8_t,
                        a: uint8_t) -> c_int;
        pub fn aalineColor(renderer: *SDL_Renderer, x1: int16_t, y1: int16_t,
                           x2: int16_t, y2: int16_t, color: uint32_t) -> c_int;
        pub fn aalineRGBA(renderer: *SDL_Renderer, x1: int16_t, y1: int16_t,
                          x2: int16_t, y2: int16_t, r: uint8_t, g: uint8_t, b: uint8_t,
                          a: uint8_t) -> c_int;
        pub fn thickLineColor(renderer: *SDL_Renderer, x1: int16_t, y1: int16_t,
                              x2: int16_t, y2: int16_t, width: uint8_t, color: uint32_t)
                              -> c_int;
        pub fn thickLineRGBA(renderer: *SDL_Renderer, x1: int16_t, y1: int16_t,
                             x2: int16_t, y2: int16_t, width: uint8_t, r: uint8_t,
                             g: uint8_t, b: uint8_t, a: uint8_t) -> c_int;
        pub fn circleColor(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                           rad: int16_t, color: uint32_t) -> c_int;
        pub fn circleRGBA(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                          rad: int16_t, r: uint8_t, g: uint8_t, b: uint8_t, a: uint8_t) ->
            c_int;
        pub fn arcColor(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                        rad: int16_t, start: int16_t, end: int16_t, color: uint32_t) ->
            c_int;
        pub fn arcRGBA(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                       rad: int16_t, start: int16_t, end: int16_t, r: uint8_t,
                       g: uint8_t, b: uint8_t, a: uint8_t) -> c_int;
        pub fn aacircleColor(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                             rad: int16_t, color: uint32_t) -> c_int;
        pub fn aacircleRGBA(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                            rad: int16_t, r: uint8_t, g: uint8_t, b: uint8_t, a: uint8_t)
                            -> c_int;
        pub fn filledCircleColor(renderer: *SDL_Renderer, x: int16_t,
                                 y: int16_t, r: int16_t, color: uint32_t) -> c_int;
        pub fn filledCircleRGBA(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                                rad: int16_t, r: uint8_t, g: uint8_t, b: uint8_t,
                                a: uint8_t) -> c_int;
        pub fn ellipseColor(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                            rx: int16_t, ry: int16_t, color: uint32_t) -> c_int;
        pub fn ellipseRGBA(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                           rx: int16_t, ry: int16_t, r: uint8_t, g: uint8_t, b: uint8_t,
                           a: uint8_t) -> c_int;
        pub fn aaellipseColor(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                              rx: int16_t, ry: int16_t, color: uint32_t) -> c_int;
        pub fn aaellipseRGBA(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                             rx: int16_t, ry: int16_t, r: uint8_t, g: uint8_t, b: uint8_t,
                             a: uint8_t) -> c_int;
        pub fn filledEllipseColor(renderer: *SDL_Renderer, x: int16_t,
                                  y: int16_t, rx: int16_t, ry: int16_t,
                                  color: uint32_t) -> c_int;
        pub fn filledEllipseRGBA(renderer: *SDL_Renderer, x: int16_t,
                                 y: int16_t, rx: int16_t, ry: int16_t, r: uint8_t,
                                 g: uint8_t, b: uint8_t, a: uint8_t) -> c_int;
        pub fn pieColor(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                        rad: int16_t, start: int16_t, end: int16_t, color: uint32_t) ->
            c_int;
        pub fn pieRGBA(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                       rad: int16_t, start: int16_t, end: int16_t, r: uint8_t,
                       g: uint8_t, b: uint8_t, a: uint8_t) -> c_int;
        pub fn filledPieColor(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                              rad: int16_t, start: int16_t, end: int16_t,
                              color: uint32_t) -> c_int;
        pub fn filledPieRGBA(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                             rad: int16_t, start: int16_t, end: int16_t, r: uint8_t,
                             g: uint8_t, b: uint8_t, a: uint8_t) -> c_int;
        pub fn trigonColor(renderer: *SDL_Renderer, x1: int16_t, y1: int16_t,
                           x2: int16_t, y2: int16_t, x3: int16_t, y3: int16_t,
                           color: uint32_t) -> c_int;
        pub fn trigonRGBA(renderer: *SDL_Renderer, x1: int16_t, y1: int16_t,
                          x2: int16_t, y2: int16_t, x3: int16_t, y3: int16_t,
                          r: uint8_t, g: uint8_t, b: uint8_t, a: uint8_t) -> c_int;
        pub fn aatrigonColor(renderer: *SDL_Renderer, x1: int16_t, y1: int16_t,
                             x2: int16_t, y2: int16_t, x3: int16_t, y3: int16_t,
                             color: uint32_t) -> c_int;
        pub fn aatrigonRGBA(renderer: *SDL_Renderer, x1: int16_t, y1: int16_t,
                            x2: int16_t, y2: int16_t, x3: int16_t, y3: int16_t,
                            r: uint8_t, g: uint8_t, b: uint8_t, a: uint8_t) -> c_int;
        pub fn filledTrigonColor(renderer: *SDL_Renderer, x1: int16_t,
                                 y1: int16_t, x2: int16_t, y2: int16_t, x3: int16_t,
                                 y3: int16_t, color: uint32_t) -> c_int;
        pub fn filledTrigonRGBA(renderer: *SDL_Renderer, x1: int16_t,
                                y1: int16_t, x2: int16_t, y2: int16_t, x3: int16_t,
                                y3: int16_t, r: uint8_t, g: uint8_t, b: uint8_t,
                                a: uint8_t) -> c_int;
        pub fn polygonColor(renderer: *SDL_Renderer, vx: *int16_t, vy: *int16_t,
                            n: c_int, color: uint32_t) -> c_int;
        pub fn polygonRGBA(renderer: *SDL_Renderer, vx: *int16_t, vy: *int16_t,
                           n: c_int, r: uint8_t, g: uint8_t, b: uint8_t, a: uint8_t) ->
            c_int;
        pub fn aapolygonColor(renderer: *SDL_Renderer, vx: *int16_t,
                              vy: *int16_t, n: c_int, color: uint32_t) -> c_int;
        pub fn aapolygonRGBA(renderer: *SDL_Renderer, vx: *int16_t,
                             vy: *int16_t, n: c_int, r: uint8_t, g: uint8_t, b: uint8_t,
                             a: uint8_t) -> c_int;
        pub fn filledPolygonColor(renderer: *SDL_Renderer, vx: *int16_t,
                                  vy: *int16_t, n: c_int, color: uint32_t) -> c_int;
        pub fn filledPolygonRGBA(renderer: *SDL_Renderer, vx: *int16_t,
                                 vy: *int16_t, n: c_int, r: uint8_t, g: uint8_t,
                                 b: uint8_t, a: uint8_t) -> c_int;
        pub fn texturedPolygon(renderer: *SDL_Renderer, vx: *int16_t,
                               vy: *int16_t, n: c_int, texture: *SDL_Surface,
                               texture_dx: c_int, texture_dy: c_int) -> c_int;
        pub fn bezierColor(renderer: *SDL_Renderer, vx: *int16_t, vy: *int16_t,
                           n: c_int, s: c_int, color: uint32_t) -> c_int;
        pub fn bezierRGBA(renderer: *SDL_Renderer, vx: *int16_t, vy: *int16_t,
                          n: c_int, s: c_int, r: uint8_t, g: uint8_t, b: uint8_t,
                          a: uint8_t) -> c_int;
        pub fn gfxPrimitivesSetFont(fontdata: *c_void, cw: uint32_t, ch: uint32_t);
        pub fn gfxPrimitivesSetFontRotation(rotation: uint32_t);
        pub fn characterColor(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                              c: c_char, color: uint32_t) -> c_int;
        pub fn characterRGBA(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                             c: c_char, r: uint8_t, g: uint8_t, b: uint8_t, a: uint8_t)
                             -> c_int;
        pub fn stringColor(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                           s: *c_char, color: uint32_t) -> c_int;
        pub fn stringRGBA(renderer: *SDL_Renderer, x: int16_t, y: int16_t,
                          s: *c_char, r: uint8_t, g: uint8_t, b: uint8_t, a: uint8_t) ->
            c_int;
    }
}

/// generic Color type
pub trait ToColor {
    fn as_RGBA(&self) -> (u8, u8, u8, u8);

    #[inline]
    fn as_u32(&self) -> u32 {
        unsafe { mem::transmute(self.as_RGBA()) }
    }
}

impl ToColor for pixels::Color {
    #[inline]
    fn as_RGBA(&self) -> (u8, u8, u8, u8) {
        match *self {
            pixels::RGB(r, g, b) => {
                (r, g, b, 255u8)
            }
            pixels::RGBA(r, g, b, a) => {
                (r, g, b, a)
            }
        }
    }
}

impl ToColor for (u8, u8, u8, u8) {
    #[inline]
    fn as_RGBA(&self) -> (u8, u8, u8, u8) {
        *self
    }

    #[inline]
    fn as_u32(&self) -> u32 {
        unsafe { mem::transmute(*self) }
    }
}

impl ToColor for u32 {
    #[inline]
    fn as_RGBA(&self) -> (u8, u8, u8, u8) {
        unsafe { mem::transmute(*self) }
    }

    #[inline]
    fn as_u32(&self) -> u32 {
        *self
    }
}

// for 0xXXXXXXXX
impl ToColor for int {
    #[inline]
    fn as_RGBA(&self) -> (u8, u8, u8, u8) {
        unsafe { mem::transmute(self.to_u32().expect("Can't convert to Color Type")) }
    }

    #[inline]
    fn as_u32(&self) -> u32 {
        self.to_u32().expect("Can't convert to Color Type")
    }
}

/// For drawing with rust-sdl2 Renderer
pub trait DrawRenderer {
    fn pixel<C: ToColor>(&self, x: i16, y: i16, color: C) -> Result<(), ~str>;
    fn hline<C: ToColor>(&self, x1: i16, x2: i16, y: i16, color: C) -> Result<(), ~str>;
    fn vline<C: ToColor>(&self, x: i16, y1: i16, y2: i16, color: C) -> Result<(), ~str>;
    fn rectangle<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, color: C) -> Result<(), ~str>;
    fn rounded_rectangle<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, rad: i16, color: C) -> Result<(), ~str>;
    fn box_<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, color: C) -> Result<(), ~str>;
    fn rounded_box<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, rad: i16, color: C) -> Result<(), ~str>;
    fn line<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, color: C) -> Result<(), ~str>;
    fn aa_line<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, color: C) -> Result<(), ~str>;
    fn thick_line<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, width: u8, color: C) -> Result<(), ~str>;
    fn circle<C: ToColor>(&self, x: i16, y: i16, rad: i16, color: C) -> Result<(), ~str>;
    fn aa_circle<C: ToColor>(&self, x: i16, y: i16, rad: i16, color: C) -> Result<(), ~str>;
    fn filled_circle<C: ToColor>(&self, x: i16, y: i16, rad: i16, color: C) -> Result<(), ~str>;
    fn arc<C: ToColor>(&self, x: i16, y: i16, rad: i16, start: i16, end: i16, color: C) -> Result<(), ~str>;
    fn ellipse<C: ToColor>(&self, x: i16, y: i16, rx: i16, ry: i16, color: C) -> Result<(), ~str>;
    fn aa_ellipse<C: ToColor>(&self, x: i16, y: i16, rx: i16, ry: i16, color: C) -> Result<(), ~str>;
    fn filled_ellipse<C: ToColor>(&self, x: i16, y: i16, rx: i16, ry: i16, color: C) -> Result<(), ~str>;
    fn pie<C: ToColor>(&self, x: i16, y: i16, rad: i16, start: i16, end: i16, color: C) -> Result<(), ~str>;
    fn filled_pie<C: ToColor>(&self, x: i16, y: i16, rad: i16, start: i16, end: i16, color: C) -> Result<(), ~str>;
    fn trigon<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, x3: i16, y3: i16, color: C) -> Result<(), ~str>;
    fn aa_trigon<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, x3: i16, y3: i16, color: C) -> Result<(), ~str>;
    fn filled_trigon<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, x3: i16, y3: i16, color: C) -> Result<(), ~str>;
    fn polygon<C: ToColor>(&self, vx: &[i16], vy: &[i16], color: C) -> Result<(), ~str>;
    fn aa_polygon<C: ToColor>(&self, vx: &[i16], vy: &[i16], color: C) -> Result<(), ~str>;
    fn filled_polygon<C: ToColor>(&self, vx: &[i16], vy: &[i16], color: C) -> Result<(), ~str>;
    fn textured_polygon<C: ToColor>(&self, vx: &[i16], vy: &[i16], texture: &Surface, texture_dx: i16, texture_dy: i16, color: C) -> Result<(), ~str>;
    fn bezier<C: ToColor>(&self, vx: &[i16], vy: &[i16], s: int, color: C) -> Result<(), ~str>;
    fn character<C: ToColor>(&self, x: i16, y: i16, c: char, color: C) -> Result<(), ~str>;
    fn string<C: ToColor>(&self, x: i16, y: i16, s: &str, color: C) -> Result<(), ~str>;
}

impl DrawRenderer for Renderer {
    fn pixel<C: ToColor>(&self, x: i16, y: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::pixelColor(self.raw, x, y, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn hline<C: ToColor>(&self, x1: i16, x2: i16, y: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::hlineColor(self.raw, x1, x2, y, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn vline<C: ToColor>(&self, x: i16, y1: i16, y2: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::vlineColor(self.raw, x, y1, y2, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn rectangle<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::rectangleColor(self.raw, x1, y1, x2, y2, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn rounded_rectangle<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, rad: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::roundedRectangleColor(self.raw, x1, y1, x2, y2, rad, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn box_<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::boxColor(self.raw, x1, y1, x2, y2, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn rounded_box<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, rad: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::roundedBoxColor(self.raw, x1, y1, x2, y2, rad, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn line<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            println!("debug => {:X}", color.as_u32());
            ll::lineColor(self.raw, x1, y1, x2, y2, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn aa_line<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::aalineColor(self.raw, x1, y1, x2, y2, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn thick_line<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, width: u8, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::thickLineColor(self.raw, x1, y1, x2, y2, width, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn circle<C: ToColor>(&self, x: i16, y: i16, rad: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::circleColor(self.raw, x, y, rad, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn aa_circle<C: ToColor>(&self, x: i16, y: i16, rad: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::aacircleColor(self.raw, x, y, rad, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn filled_circle<C: ToColor>(&self, x: i16, y: i16, rad: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::filledCircleColor(self.raw, x, y, rad, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn arc<C: ToColor>(&self, x: i16, y: i16, rad: i16, start: i16, end: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::arcColor(self.raw, x, y, rad, start, end, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn ellipse<C: ToColor>(&self, x: i16, y: i16, rx: i16, ry: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::ellipseColor(self.raw, x, y, rx, ry, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn aa_ellipse<C: ToColor>(&self, x: i16, y: i16, rx: i16, ry: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::aaellipseColor(self.raw, x, y, rx, ry, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn filled_ellipse<C: ToColor>(&self, x: i16, y: i16, rx: i16, ry: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::filledEllipseColor(self.raw, x, y, rx, ry, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn pie<C: ToColor>(&self, x: i16, y: i16, rad: i16, start: i16, end: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::pieColor(self.raw, x, y, rad, start, end, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn filled_pie<C: ToColor>(&self, x: i16, y: i16, rad: i16, start: i16, end: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::filledPieColor(self.raw, x, y, rad, start, end, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn trigon<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, x3: i16, y3: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::trigonColor(self.raw, x1, y1, x2, y2, x3, y3, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn aa_trigon<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, x3: i16, y3: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::aatrigonColor(self.raw, x1, y1, x2, y2, x3, y3, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    fn filled_trigon<C: ToColor>(&self, x1: i16, y1: i16, x2: i16, y2: i16, x3: i16, y3: i16, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::filledTrigonColor(self.raw, x1, y1, x2, y2, x3, y3, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    // FIXME: may we use pointer tuple?
    fn polygon<C: ToColor>(&self, vx: &[i16], vy: &[i16], color: C) -> Result<(), ~str> {
        assert_eq!(vx.len(), vy.len());
        let n = vx.len() as c_int;
        let ret = unsafe {
            ll::polygonColor(self.raw, vx.as_ptr(), vy.as_ptr(), n, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }

    fn aa_polygon<C: ToColor>(&self, vx: &[i16], vy: &[i16], color: C) -> Result<(), ~str> {
        assert_eq!(vx.len(), vy.len());
        let n = vx.len() as c_int;
        let ret = unsafe {
            ll::aapolygonColor(self.raw, vx.as_ptr(), vy.as_ptr(), n, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }

    fn filled_polygon<C: ToColor>(&self, vx: &[i16], vy: &[i16], color: C) -> Result<(), ~str> {
        assert_eq!(vx.len(), vy.len());
        let n = vx.len() as c_int;
        let ret = unsafe {
            ll::filledPolygonColor(self.raw, vx.as_ptr(), vy.as_ptr(), n, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
    #[allow(unused_variable)]
    fn textured_polygon<C: ToColor>(&self, vx: &[i16], vy: &[i16], texture: &Surface, texture_dx: i16, texture_dy: i16, color: C) -> Result<(), ~str> {
        unimplemented!()
    }

    fn bezier<C: ToColor>(&self, vx: &[i16], vy: &[i16], s: int, color: C) -> Result<(), ~str> {
        assert_eq!(vx.len(), vy.len());
        let n = vx.len() as c_int;
        let ret = unsafe {
            ll::bezierColor(self.raw, vx.as_ptr(), vy.as_ptr(), n, s as c_int, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }

    fn character<C: ToColor>(&self, x: i16, y: i16, c: char, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            ll::characterColor(self.raw, x, y, c as c_char, color.as_u32())
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }

    fn string<C: ToColor>(&self, x: i16, y: i16, s: &str, color: C) -> Result<(), ~str> {
        let ret = unsafe {
            s.with_c_str(|buf| {
                ll::stringColor(self.raw, x, y, buf as *i8, color.as_u32())
            })
        };
        if ret == 0 { Ok(()) }
        else { Err(get_error()) }
    }
}

/// Sets or resets the current global font data.
pub fn set_font(fontdata: Option<&[u8]>, cw: uint, ch: uint) {
    let actual_fontdata = match fontdata {
        None  => ptr::null(),
        Some(v) => v.as_ptr()
    };
    unsafe {
        ll::gfxPrimitivesSetFont(actual_fontdata as *c_void, cw as u32, ch as u32)
    }
}

/// Sets current global font character rotation steps.
pub fn set_font_rotation(rotation: uint) {
    unsafe { ll::gfxPrimitivesSetFontRotation(rotation as u32) }
}
