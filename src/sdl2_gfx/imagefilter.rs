//! MMX image filters

use std::cast;
use std::c_vec::CVec;
use libc;
use libc::{size_t, c_void, c_uint, c_int};

mod ll {
    /* automatically generated by rust-bindgen */

    use libc::*;
    extern "C" {
        pub fn SDL_imageFilterMMXdetect() -> c_int;
        pub fn SDL_imageFilterMMXoff();
        pub fn SDL_imageFilterMMXon();
        pub fn SDL_imageFilterAdd(Src1: *u8, Src2: *u8,
                                  Dest: *u8, length: c_uint) -> c_int;
        pub fn SDL_imageFilterMean(Src1: *u8, Src2: *u8,
                                   Dest: *u8, length: c_uint) -> c_int;
        pub fn SDL_imageFilterSub(Src1: *u8, Src2: *u8,
                                  Dest: *u8, length: c_uint) -> c_int;
        pub fn SDL_imageFilterAbsDiff(Src1: *u8, Src2: *u8,
                                      Dest: *u8, length: c_uint) ->
            c_int;
        pub fn SDL_imageFilterMult(Src1: *u8, Src2: *u8,
                                   Dest: *u8, length: c_uint) -> c_int;
        pub fn SDL_imageFilterMultNor(Src1: *u8, Src2: *u8,
                                      Dest: *u8, length: c_uint) ->
            c_int;
        pub fn SDL_imageFilterMultDivby2(Src1: *u8, Src2: *u8,
                                         Dest: *u8, length: c_uint) ->
            c_int;
        pub fn SDL_imageFilterMultDivby4(Src1: *u8, Src2: *u8,
                                         Dest: *u8, length: c_uint) ->
            c_int;
        pub fn SDL_imageFilterBitAnd(Src1: *u8, Src2: *u8,
                                     Dest: *u8, length: c_uint) -> c_int;
        pub fn SDL_imageFilterBitOr(Src1: *u8, Src2: *u8,
                                    Dest: *u8, length: c_uint) -> c_int;
        pub fn SDL_imageFilterDiv(Src1: *u8, Src2: *u8,
                                  Dest: *u8, length: c_uint) -> c_int;
        pub fn SDL_imageFilterBitNegation(Src1: *u8, Dest: *u8,
                                          length: c_uint) -> c_int;
        pub fn SDL_imageFilterAddByte(Src1: *u8, Dest: *u8,
                                      length: c_uint, C: u8) -> c_int;
        pub fn SDL_imageFilterAddUint(Src1: *u8, Dest: *u8,
                                      length: c_uint, C: c_uint) -> c_int;
        pub fn SDL_imageFilterAddByteToHalf(Src1: *u8,
                                            Dest: *u8, length: c_uint,
                                            C: u8) -> c_int;
        pub fn SDL_imageFilterSubByte(Src1: *u8, Dest: *u8,
                                      length: c_uint, C: u8) -> c_int;
        pub fn SDL_imageFilterSubUint(Src1: *u8, Dest: *u8,
                                      length: c_uint, C: c_uint) -> c_int;
        pub fn SDL_imageFilterShiftRight(Src1: *u8, Dest: *u8,
                                         length: c_uint, N: u8) -> c_int;
        pub fn SDL_imageFilterShiftRightUint(Src1: *u8,
                                             Dest: *u8, length: c_uint,
                                             N: u8) -> c_int;
        pub fn SDL_imageFilterMultByByte(Src1: *u8, Dest: *u8,
                                         length: c_uint, C: u8) -> c_int;
        pub fn SDL_imageFilterShiftRightAndMultByByte(Src1: *u8,
                                                      Dest: *u8,
                                                      length: c_uint, N: u8,
                                                      C: u8) -> c_int;
        pub fn SDL_imageFilterShiftLeftByte(Src1: *u8,
                                            Dest: *u8, length: c_uint,
                                            N: u8) -> c_int;
        pub fn SDL_imageFilterShiftLeftUint(Src1: *u8,
                                            Dest: *u8, length: c_uint,
                                            N: u8) -> c_int;
        pub fn SDL_imageFilterShiftLeft(Src1: *u8, Dest: *u8,
                                        length: c_uint, N: u8) -> c_int;
        pub fn SDL_imageFilterBinarizeUsingThreshold(Src1: *u8,
                                                     Dest: *u8,
                                                     length: c_uint, T: u8)
                                                     -> c_int;
        pub fn SDL_imageFilterClipToRange(Src1: *u8, Dest: *u8,
                                          length: c_uint, Tmin: u8,
                                          Tmax: u8) -> c_int;
        pub fn SDL_imageFilterNormalizeLinear(Src: *u8,
                                              Dest: *u8, length: c_uint,
                                              Cmin: c_int, Cmax: c_int,
                                              Nmin: c_int, Nmax: c_int) -> c_int;
    }
}

/// MMX detection routine (with override flag).
pub fn mmx_detect() -> bool {
    unsafe { ll::SDL_imageFilterMMXdetect() == 1 }
}

/// Disable MMX check for filter functions and and force to use non-MMX C based code.
pub fn mmx_off() {
    unsafe { ll::SDL_imageFilterMMXoff() }
}

/// Enable MMX check for filter functions and use MMX code if available.
pub fn mmx_on() {
    unsafe { ll::SDL_imageFilterMMXon() }
}

#[inline]
fn cvec_with_size(sz: uint) -> CVec<u8> {
    unsafe {
        let p = libc::malloc(sz as size_t) as *mut u8;
        CVec::new_with_dtor(p, sz, proc() {
            libc::free(p as *mut c_void)
        })
    }
}

/// Filter using Add: D = saturation255(S1 + S2).
pub fn add(src1: CVec<u8>, src2: CVec<u8>) -> Result<CVec<u8>, ~str> {
    assert_eq!(src1.len(), src2.len());
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterAdd(cast::transmute(src1.get(0)),
                                              cast::transmute(src2.get(0)),
                                              cast::transmute(dest.get(0)),
                                              size as c_uint) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterAdd error".to_owned()) }
}

/// Filter using Mean: D = S1/2 + S2/2.
pub fn mean(src1: CVec<u8>, src2: CVec<u8>) -> Result<CVec<u8>, ~str> {
    assert_eq!(src1.len(), src2.len());
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterMean(cast::transmute(src1.get(0)),
                                               cast::transmute(src2.get(0)),
                                               cast::transmute(dest.get(0)),
                                               size as c_uint) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterMean error".to_owned()) }
}

/// Filter using Sub: D = saturation0(S1 - S2).
pub fn sub(src1: CVec<u8>, src2: CVec<u8>) -> Result<CVec<u8>, ~str> {
    assert_eq!(src1.len(), src2.len());
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterSub(cast::transmute(src1.get(0)),
                                              cast::transmute(src2.get(0)),
                                              cast::transmute(dest.get(0)),
                                              size as c_uint) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterSub error".to_owned()) }
}

/// Filter using AbsDiff: D = | S1 - S2 |.
pub fn abs_diff(src1: CVec<u8>, src2: CVec<u8>) -> Result<CVec<u8>, ~str> {
    assert_eq!(src1.len(), src2.len());
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterAbsDiff(cast::transmute(src1.get(0)),
                                                  cast::transmute(src2.get(0)),
                                                  cast::transmute(dest.get(0)),
                                                  size as c_uint) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterAbsDiff error".to_owned()) }
}

/// Filter using Mult: D = saturation255(S1 * S2).
pub fn mult(src1: CVec<u8>, src2: CVec<u8>) -> Result<CVec<u8>, ~str> {
    assert_eq!(src1.len(), src2.len());
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterMult(cast::transmute(src1.get(0)),
                                               cast::transmute(src2.get(0)),
                                               cast::transmute(dest.get(0)),
                                               size as c_uint) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterMult error".to_owned()) }
}

/// Filter using MultNor: D = S1 * S2.
pub fn mult_nor(src1: CVec<u8>, src2: CVec<u8>) -> Result<CVec<u8>, ~str> {
    assert_eq!(src1.len(), src2.len());
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterMultNor(cast::transmute(src1.get(0)),
                                                  cast::transmute(src2.get(0)),
                                                  cast::transmute(dest.get(0)),
                                                  size as c_uint) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterMultNor error".to_owned()) }
}

/// Filter using MultDivby2: D = saturation255(S1/2 * S2).
pub fn mult_div_by2(src1: CVec<u8>, src2: CVec<u8>) -> Result<CVec<u8>, ~str> {
    assert_eq!(src1.len(), src2.len());
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterMultDivby2(cast::transmute(src1.get(0)),
                                                     cast::transmute(src2.get(0)),
                                                     cast::transmute(dest.get(0)),
                                                     size as c_uint) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterMultDivby2 error".to_owned()) }
}

/// Filter using MultDivby4: D = saturation255(S1/2 * S2/2).
pub fn mult_div_by4(src1: CVec<u8>, src2: CVec<u8>) -> Result<CVec<u8>, ~str> {
    assert_eq!(src1.len(), src2.len());
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterMultDivby4(cast::transmute(src1.get(0)),
                                                     cast::transmute(src2.get(0)),
                                                     cast::transmute(dest.get(0)),
                                                     size as c_uint) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterMultDivby4 error".to_owned()) }
}

/// Filter using BitAnd: D = S1 & S2.
pub fn bit_and(src1: CVec<u8>, src2: CVec<u8>) -> Result<CVec<u8>, ~str> {
    assert_eq!(src1.len(), src2.len());
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterBitAnd(cast::transmute(src1.get(0)),
                                                 cast::transmute(src2.get(0)),
                                                 cast::transmute(dest.get(0)),
                                                 size as c_uint) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterBitAnd error".to_owned()) }
}

/// Filter using BitOr: D = S1 | S2.
pub fn bit_or(src1: CVec<u8>, src2: CVec<u8>) -> Result<CVec<u8>, ~str> {
    assert_eq!(src1.len(), src2.len());
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterBitOr(cast::transmute(src1.get(0)),
                                                cast::transmute(src2.get(0)),
                                                cast::transmute(dest.get(0)),
                                                size as c_uint) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterBitOr error".to_owned()) }
}

/// Filter using Div: D = S1 / S2.
pub fn div(src1: CVec<u8>, src2: CVec<u8>) -> Result<CVec<u8>, ~str> {
    assert_eq!(src1.len(), src2.len());
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterDiv(cast::transmute(src1.get(0)),
                                              cast::transmute(src2.get(0)),
                                              cast::transmute(dest.get(0)),
                                              size as c_uint) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterDiv error".to_owned()) }
}

/// Filter using BitNegation: D = !S.
pub fn bit_negation(src1: CVec<u8>) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterBitNegation(cast::transmute(src1.get(0)),
                                                      cast::transmute(dest.get(0)),
                                                      size as c_uint) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterBitNegation error".to_owned()) }
}

/// Filter using AddByte: D = saturation255(S + C).
pub fn add_byte(src1: CVec<u8>, c: u8) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterAddByte(cast::transmute(src1.get(0)),
                                                  cast::transmute(dest.get(0)),
                                                  size as c_uint, c) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterAddByte error".to_owned()) }
}

/// Filter using AddUint: D = saturation255((S[i] + Cs[i % 4]), Cs=Swap32((uint)C).
pub fn add_uint(src1: CVec<u8>, c: u32) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterAddUint(cast::transmute(src1.get(0)),
                                                  cast::transmute(dest.get(0)),
                                                  size as c_uint, c) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterAddUint error".to_owned()) }
}

/// Filter using AddByteToHalf: D = saturation255(S/2 + C).
pub fn add_byte_to_half(src1: CVec<u8>, c: u8) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterAddByteToHalf(cast::transmute(src1.get(0)),
                                                        cast::transmute(dest.get(0)),
                                                        size as c_uint, c) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterAddByteToHalf error".to_owned()) }
}

/// Filter using SubByte: D = saturation0(S - C).
pub fn sub_byte(src1: CVec<u8>, c: u8) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterSubByte(cast::transmute(src1.get(0)),
                                                  cast::transmute(dest.get(0)),
                                                  size as c_uint, c) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterSubByte error".to_owned()) }
}

/// Filter using SubUint: D = saturation0(S[i] - Cs[i % 4]), Cs=Swap32((uint)C).
pub fn sub_uint(src1: CVec<u8>, c: u32) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterSubUint(cast::transmute(src1.get(0)),
                                                  cast::transmute(dest.get(0)),
                                                  size as c_uint, c) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterSubUint error".to_owned()) }
}

/// Filter using ShiftRight: D = saturation0(S >> N).
pub fn shift_right(src1: CVec<u8>, n: u8) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterShiftRight(cast::transmute(src1.get(0)),
                                                     cast::transmute(dest.get(0)),
                                                     size as c_uint, n) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterShiftRight error".to_owned()) }
}

/// Filter using ShiftRightUint: D = saturation0((uint)S[i] >> N).
pub fn shift_right_uint(src1: CVec<u8>, n: u8) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterShiftRightUint(cast::transmute(src1.get(0)),
                                                         cast::transmute(dest.get(0)),
                                                         size as c_uint, n) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterShiftRightUint error".to_owned()) }
}

/// Filter using MultByByte: D = saturation255(S * C).
pub fn mult_by_byte(src1: CVec<u8>, c: u8) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterMultByByte(cast::transmute(src1.get(0)),
                                                     cast::transmute(dest.get(0)),
                                                     size as c_uint, c) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterMultByByte error".to_owned()) }
}

/// Filter using ShiftRightAndMultByByte: D = saturation255((S >> N) * C).
pub fn shift_right_and_mult_by_byte(src1: CVec<u8>, n: u8, c: u8) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterShiftRightAndMultByByte(cast::transmute(src1.get(0)),
                                                                  cast::transmute(dest.get(0)),
                                                                  size as c_uint, n, c) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterShiftRightAndMultByByte error".to_owned()) }
}

/// Filter using ShiftLeftByte: D = (S << N).
pub fn shift_left_byte(src1: CVec<u8>, n: u8) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterShiftLeftByte(cast::transmute(src1.get(0)),
                                                        cast::transmute(dest.get(0)),
                                                        size as c_uint, n) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterShiftLeftByte error".to_owned()) }
}

/// Filter using ShiftLeftUint: D = ((uint)S << N).
pub fn shift_left_uint(src1: CVec<u8>, n: u8) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterShiftLeftUint(cast::transmute(src1.get(0)),
                                                        cast::transmute(dest.get(0)),
                                                        size as c_uint, n) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterShiftLeftUint error".to_owned()) }
}

/// Filter ShiftLeft: D = saturation255(S << N).
pub fn shift_left(src1: CVec<u8>, n: u8) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterShiftLeft(cast::transmute(src1.get(0)),
                                                    cast::transmute(dest.get(0)),
                                                    size as c_uint, n) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterShiftLeft error".to_owned()) }
}

/// Filter using BinarizeUsingThreshold: D = (S >= T) ? 255:0.
pub fn binarize_using_threshold(src1: CVec<u8>, t: u8) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterBinarizeUsingThreshold(cast::transmute(src1.get(0)),
                                                                 cast::transmute(dest.get(0)),
                                                                 size as c_uint, t) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterBinarizeUsingThreshold error".to_owned()) }
}

/// Filter using ClipToRange: D = (S >= Tmin) & (S <= Tmax) S:Tmin | Tmax.
pub fn clip_to_range(src1: CVec<u8>, tmin: u8, tmax: u8) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterClipToRange(cast::transmute(src1.get(0)),
                                                      cast::transmute(dest.get(0)),
                                                      size as c_uint, tmin, tmax) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterClipToRange error".to_owned()) }
}

/// Filter using NormalizeLinear: D = saturation255((Nmax - Nmin)/(Cmax - Cmin)*(S - Cmin) + Nmin).
pub fn normalize_linear(src1: CVec<u8>, cmin: int, cmax: int, nmin: int, nmax: int) -> Result<CVec<u8>, ~str> {
    let size = src1.len();
    let dest = cvec_with_size(size);
    let ret = unsafe { ll::SDL_imageFilterNormalizeLinear(cast::transmute(src1.get(0)),
                                                          cast::transmute(dest.get(0)),
                                                          size as c_uint,
                                                          cmin as c_int, cmax as c_int,
                                                          nmin as c_int, nmax as c_int) };
    if ret == 0 { Ok(dest) }
    else { Err("SDL_imageFilterNormalizeLinear error".to_owned()) }
}
