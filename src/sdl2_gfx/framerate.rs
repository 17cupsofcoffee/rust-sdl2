use libc;
use libc::{c_void, uint32_t, malloc};
use std::mem;


mod ll {
    /* automatically generated by rust-bindgen */

    use libc::*;
    pub struct FPSmanager {
        pub framecount: uint32_t,
        pub rateticks: c_float,
        pub baseticks: uint32_t,
        pub lastticks: uint32_t,
        pub rate: uint32_t,
    }
    extern "C" {
        pub fn SDL_initFramerate(manager: *mut FPSmanager);
        pub fn SDL_setFramerate(manager: *mut FPSmanager, rate: uint32_t) -> c_int;
        pub fn SDL_getFramerate(manager: *mut FPSmanager) -> c_int;
        pub fn SDL_getFramecount(manager: *mut FPSmanager) -> c_int;
        pub fn SDL_framerateDelay(manager: *mut FPSmanager) -> uint32_t;
    }
}

/// Structure holding the state and timing information of the framerate controller.
pub struct FPSManager {
    raw: *mut ll::FPSmanager,
}

impl FPSManager {
    /// Create the framerate manager.
    pub fn new() -> FPSManager {
        unsafe {
            let raw = libc::malloc(mem::size_of::<ll::FPSmanager>() as u64) as *mut ll::FPSmanager;
            ll::SDL_initFramerate(raw);
            FPSManager { raw: raw }
        }
    }

    /// Set the framerate in Hz.
    pub fn set_framerate(&mut self, rate: uint) -> Result<(), ~str> {
        let ret = unsafe { ll::SDL_setFramerate(self.raw, rate as uint32_t) };
        if ret == 0 { Ok(()) }
        else { Err(~"set_framerate error: beyond lower/upper limit.") }
    }

    /// Return the current target framerate in Hz.
    pub fn get_framerate(&self) -> int {
        // will not get an error
        unsafe { ll::SDL_getFramerate(self.raw) as int }
    }

    /// Return the current framecount.
    pub fn get_framecount(&self) -> int {
        // will not get an error
        unsafe { ll::SDL_getFramecount(self.raw) as int }
    }

    /// Delay execution to maintain a constant framerate and calculate fps.
    pub fn framerate_delay(&mut self) -> uint {
        unsafe { ll::SDL_framerateDelay(self.raw) as uint }
    }
}

impl Drop for FPSManager {
    fn drop(&mut self) {
        unsafe { libc::free(self.raw as *mut c_void) }
    }
}
