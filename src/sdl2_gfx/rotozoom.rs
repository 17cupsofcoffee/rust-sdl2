use libc::c_int;
use sdl2::surface::Surface;
pub use std::f64::consts::PI;


mod ll {
    /* automatically generated by rust-bindgen */

    use libc::*;
    use sdl2::surface::ll::SDL_Surface;
    extern "C" {
        pub fn rotozoomSurface(src: *SDL_Surface, angle: c_double,
                               zoom: c_double, smooth: c_int) -> *SDL_Surface;
        pub fn rotozoomSurfaceXY(src: *SDL_Surface, angle: c_double,
                                 zoomx: c_double, zoomy: c_double, smooth: c_int)
                                 -> *SDL_Surface;
        pub fn rotozoomSurfaceSize(width: c_int, height: c_int, angle: c_double,
                                   zoom: c_double, dstwidth: *c_int,
                                   dstheight: *c_int);
        pub fn rotozoomSurfaceSizeXY(width: c_int, height: c_int, angle: c_double,
                                     zoomx: c_double, zoomy: c_double,
                                     dstwidth: *c_int, dstheight: *c_int);
        pub fn zoomSurface(src: *SDL_Surface, zoomx: c_double,
                           zoomy: c_double, smooth: c_int) -> *SDL_Surface;
        pub fn zoomSurfaceSize(width: c_int, height: c_int, zoomx: c_double,
                               zoomy: c_double, dstwidth: *c_int,
                               dstheight: *c_int);
        pub fn shrinkSurface(src: *SDL_Surface, factorx: c_int,
                             factory: c_int) -> *SDL_Surface;
        pub fn rotateSurface90Degrees(src: *SDL_Surface,
                                      numClockwiseTurns: c_int) ->
            *SDL_Surface;
    }
}

pub trait RotozoomSurface {
    fn rotozoom(&self, angle: f64, zoom: f64, smooth: bool) -> Result<~Surface, ~str>;
    fn rotozoom_xy(&self, angle: f64, zoomx: f64, zoomy: f64, smooth: bool) -> Result<~Surface, ~str>;
    fn zoom(&self, zoomx: f64, zoomy: f64, smooth: bool) -> Result<~Surface, ~str>;
    fn shrink(&self, factorx: int, factory: int) -> Result<~Surface, ~str>;
    fn rotate_90deg(&self, turns: int) -> Result<~Surface, ~str>;
}

impl RotozoomSurface for Surface {
    fn rotozoom(&self, angle: f64, zoom: f64, smooth: bool) -> Result<~Surface, ~str> {
        let raw = unsafe {
            ll::rotozoomSurface(self.raw, angle, zoom, smooth as c_int)
        };
        if raw.is_null() {
            Err(~"rotozoomSurface: error.")
        } else {
            Ok(~Surface { raw: raw, owned: true })
        }
    }
    fn rotozoom_xy(&self, angle: f64, zoomx: f64, zoomy: f64, smooth: bool) -> Result<~Surface, ~str> {
        let raw = unsafe {
            ll::rotozoomSurfaceXY(self.raw, angle, zoomx, zoomy, smooth as c_int)
        };
        if raw.is_null() {
            Err(~"rotozoomSurfaceXY: error.")
        } else {
            Ok(~Surface { raw: raw, owned: true })
        }
    }
    fn zoom(&self, zoomx: f64, zoomy: f64, smooth: bool) -> Result<~Surface, ~str> {
        let raw = unsafe {
            ll::zoomSurface(self.raw, zoomx, zoomy, smooth as c_int)
        };
        if raw.is_null() {
            Err(~"zoomSurface: error.")
        } else {
            Ok(~Surface { raw: raw, owned: true })
        }
    }
    fn shrink(&self, factorx: int, factory: int) -> Result<~Surface, ~str> {
        let raw = unsafe {
            ll::shrinkSurface(self.raw, factorx as c_int, factory as c_int)
        };
        if raw.is_null() {
            Err(~"shrinkSurface: error.")
        } else {
            Ok(~Surface { raw: raw, owned: true })
        }
    }
    fn rotate_90deg(&self, turns: int) -> Result<~Surface, ~str> {
        let raw = unsafe {
            ll::rotateSurface90Degrees(self.raw, turns as c_int)
        };
        if raw.is_null() {
            Err(~"rotateSurface90Degrees: error.")
        } else {
            Ok(~Surface { raw: raw, owned: true })
        }
    }
}




pub fn get_zoom_size(width: int, height: int, zoomx: f64, zoomy: f64) -> (int, int) {
    let w = 0;
    let h = 0;
    unsafe { ll::zoomSurfaceSize(width as c_int, height as c_int, zoomx, zoomy, &w, &h) }
    (w as int, h as int)
}

pub fn get_rotozoom_size(width: int, height: int, angle: f64, zoom: f64) -> (int, int) {
    let w = 0;
    let h = 0;
    unsafe { ll::rotozoomSurfaceSize(width as c_int, height as c_int, angle, zoom, &w, &h) }
    (w as int, h as int)
}

pub fn get_rotozoom_xy_size(width: int, height: int, angle: f64, zoomx: f64, zoomy: f64) -> (int, int) {
    let w = 0;
    let h = 0;
    unsafe { ll::rotozoomSurfaceSizeXY(width as c_int, height as c_int, angle, zoomx, zoomy, &w, &h) }
    (w as int, h as int)
}
